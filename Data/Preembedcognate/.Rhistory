gamma_all <- -(eval.fd(r_full, deltaK_fd)-glterm_fun[,-n_time_steps]) / (2 * pi * (rB + r_full))
if (SAVE) {
pdf(paste(working_dir, '/gamma_timeVarying.pdf', sep=''))
fds_gamma_fd <- fds(x=r_full, y=gamma_all)
plot(fds_gamma_fd, xlab="r", ylab="gamma", xlim=range(r_full))
dev.off()
}
# Though we use an order of 6 to smooth the K functions (in order to be able to estimate a smooth lambda'(r,t))
# we do not need to use an order of 6 when fitting f and D, an order of 4 will suffice:
Norder_reg = 4
print(paste('Order for regression =', Norder_reg))
if (is.null(abs_rmin)) {
abs_rmin <- 0
}
if (is.null(abs_rmax)) {
abs_rmax <- r_full[length(r_full)]
}
if(TVAR){
# Which r_full values are WITHIN the user-specified scope? Assign TRUE to these, and use 'which' to retrieve indices.
r_usr_abs_indices <- which(abs_rmin <= r_full & r_full <= abs_rmax)  # These indices represent r values to be INCLUDED.
rmin_index <- min(r_usr_abs_indices)
rmax_index <- max(r_usr_abs_indices)
rmin <- r_full[rmin_index]  # min & max r values, as defined by valid values lambda_r
rmax <- r_full[rmax_index]
r_trunc_indices <- rmin_index:rmax_index
r_trunc_values <- r_full[r_trunc_indices]
f_tvar = matrix(NA, length(r_full), n_time_steps)
f_tvar_stderr = matrix(NA, length(r_full), n_time_steps)
D_tvar = matrix(NA, length(r_full), n_time_steps)
F_tvar = matrix(NA, 1, n_time_steps)
# Calculate f and D for a subset of time (window). The window is shifted from start to end of available time points.
# Window operates over a subset of time.
window_centre_indices = (1 + half_time_window_width):(n_time_steps - 1 - half_time_window_width)
# Store f & D series for each window. Used for plotting later.
nsplines_gamma = min(nsplines,150)
window_centre <- window_centre_indices[1]
for(window_centre in window_centre_indices) {
# Which time indices the window is currently operating over.
window_coverage <- (window_centre - half_time_window_width):(window_centre + half_time_window_width)
print(paste("Window centred at time step ", window_centre, '; r values used = [', rmin, ', ', rmax, '].', sep=''))
gamma_splinebasis_trc <- create.bspline.basis(c(rmin, rmax), nsplines_gamma, norder=Norder_reg)
gamma <- gamma_all[r_trunc_indices, window_coverage]  # Subset that window is operating over.
# gamma_fd <- Data2fd(argvals=r_trunc_values, y=gamma, basisobj=gamma_splinebasis_trc)
gamma_fdPar <- fdPar(fdobj=gamma_splinebasis_trc, Lfdobj=NULL, lambda=10^-10)
gamma_fd <- smooth.basis(argvals=r_trunc_values,
y=gamma,
fdParobj=gamma_fdPar)
f_term <- lambda_r  # Doesn't do anything, but kept for clarity w.r.t. the accompanying paper.
D_term <- lambda_dr
f_term_fd <- Data2fd(argvals=r_trunc_values, y=f_term[r_trunc_indices, window_coverage], basisobj=gamma_splinebasis_trc)
D_term_fd <- Data2fd(argvals=r_trunc_values, y=D_term[r_trunc_indices, window_coverage], basisobj=gamma_splinebasis_trc)
unused = tryCatch(
{
# Fit functional data model.
# Estimate D using a B-spline bases, with D varying with r, or a constant basis function, without varyation in r.
constbasis_trc <- create.constant.basis(c(rmin, rmax))
if (Dconst) {
gamma_fRegress <- fRegress(gamma_fd$fd,
xfdlist=list(f_term_fd, D_term_fd),
betalist=list(fdPar(gamma_splinebasis_trc),
fdPar(constbasis_trc)))
} else {
f_splinebasis_trc <- create.bspline.basis(range(r_trunc_values), splines_f, norder=4)
betafdPar_f = fdPar(f_splinebasis_trc, Lfdobj=NULL, lambda=lambda_f)
D_splinebasis_trc <- create.bspline.basis(range(r_trunc_values), splines_D, norder=4)
betafdPar_D = fdPar(D_splinebasis_trc, Lfdobj=NULL, lambda=lambda_D)
gamma_fRegress <- fRegress(gamma_fd$fd,
xfdlist=list(f_term_fd, D_term_fd),
betalist=list(betafdPar_f,
betafdPar_D))
}
gamma_betaestlist <- gamma_fRegress$betaestlist
f_tvar[r_trunc_indices, window_centre] <- eval.fd(r_trunc_values,  gamma_betaestlist[[1]]$fd)
D_tvar[r_trunc_indices, window_centre] <- eval.fd(r_trunc_values, -gamma_betaestlist[[2]]$fd)
f_func = function(r)eval.fd(r,  gamma_betaestlist[[1]]$fd)
F_tvar[window_centre] = integrate(f_func,min(r_trunc_values),max(r_trunc_values))[[1]]
gamma_yhat_mat <- eval.fd(r_trunc_values, gamma_fRegress$yhatfdobj$fd)
gamma_rmatb   <- gamma - gamma_yhat_mat
gamma_sigma_eb <- var(t(gamma_rmatb))
gamma_y2cMap <- gamma_fd$y2cMap
# Produce standard error to produce 95% confidence intervals:
gamma_betastderrlist <- fRegress.stderr(gamma_fRegress,
gamma_y2cMap,
gamma_sigma_eb)
betastderrlist = gamma_betastderrlist$betastderrlist
f_tvar_stderr[r_trunc_indices, window_centre] <- eval.fd(r_trunc_values,  betastderrlist[[1]])
}, error = function(err) {
print("Error generated whilst performing functional regression with window coverage and r values described above")
print("  This time series will not be included in the final analysis.")
}
)  # END tryCatch
}
# Save plots to working directory
if (SAVE) {
write.csv(f_tvar, file=paste(working_dir, "/f", ".csv", sep=''), row.names=FALSE)
write.csv(D_tvar, file=paste(working_dir, "/D", ".csv", sep=''), row.names=FALSE)
Xi = n_agents_B
write.csv(Xi, file=paste(working_dir, "/Xi", ".csv", sep=''), row.names=FALSE)
pdf(paste(working_dir, '/f_timeVarying.pdf', sep=''))
fds_f_mat = fds(x=r_trunc_values, y=f_tvar[r_trunc_indices,window_centre_indices])
fds_f_mat = fds(x=r_trunc_values, y=f_tvar[r_trunc_indices,])
# MNR commented out on 20181127 to force common ylim values across all representative well experiments.
# plot(fds_f_mat, xlab="r", ylab="f",ylim=c(min(f_tvar, na.rm=TRUE), max(f_tvar, na.rm=TRUE)), xlim=c(0,max(r_full)))
plot(fds_f_mat, xlab="r", ylab="f",
ylim=c(-max(abs(f_tvar[r_trunc_indices,window_centre_indices])),
max(abs(f_tvar[r_trunc_indices,window_centre_indices]))),
xlim=c(0,max(r_full)))
dev.off()
pdf(paste(working_dir, '/D_timeVarying.pdf', sep=''))
fds_D_mat <- fds(x=r_trunc_values, y=D_tvar[r_trunc_indices,window_centre_indices])
plot(fds_D_mat, xlab="r", ylab="D", ylim=c(min(D_tvar, 0, na.rm=TRUE), max(D_tvar, na.rm=TRUE)),xlim=c(0,max(r_full)))
dev.off()
# Plot data as surfaces to separate out time and r.
source("diverge_anchored.R")
# Surface of f_tvar
plot_surface(x=r_trunc_values,
y=times_unique[window_centre_indices]*tau/60,
z=f_tvar[r_trunc_indices,window_centre_indices], centred_val=0,
path=paste(working_dir, '/f_timeVarying_surface.pdf', sep=''),
xlim=c(0,max(r_full)),
ylim=range(times_unique*tau/60),
zlim=c(-max(abs(f_tvar[r_trunc_indices,window_centre_indices])),
max(abs(f_tvar[r_trunc_indices,window_centre_indices]))))
}
}else{
# Which r_full values are WITHIN the user-specified scope? Assign TRUE to these, and use 'which' to retrieve indices.
r_usr_abs_indices <- which(abs_rmin <= r_full & r_full <= abs_rmax)  # These indices represent r values to be INCLUDED.
rmin_index <- min(r_usr_abs_indices)
rmax_index <- max(r_usr_abs_indices)
rmin <- r_full[rmin_index]  # min & max r values, as defined by valid values lambda_r
rmax <- r_full[rmax_index]
r_trunc_indices <- rmin_index:rmax_index
r_trunc_values <- r_full[r_trunc_indices]
gamma = gamma_all[r_trunc_indices,]
gamma_splinebasis_trc <- create.bspline.basis(c(rmin, rmax), nsplines, norder=Norder)
gamma_fdPar <- fdPar(fdobj=gamma_splinebasis_trc, Lfdobj=NULL, lambda=10^-10)
gamma_fd <- smooth.basis(argvals=r_trunc_values,
y=gamma,
fdParobj=gamma_fdPar)
f_term <- lambda_r
D_term <- lambda_dr
f_term_fd <- Data2fd(argvals=r_trunc_values, y=f_term[r_trunc_indices, -n_time_steps], basisobj=gamma_splinebasis_trc)
D_term_fd <- Data2fd(argvals=r_trunc_values, y=D_term[r_trunc_indices, -n_time_steps], basisobj=gamma_splinebasis_trc)
# Fit functional data model:
constbasis_trc <- create.constant.basis(range(r_trunc_values))
f_splinebasis_trc <- create.bspline.basis(range(r_trunc_values), splines_f, norder=4)
betafdPar_f = fdPar(f_splinebasis_trc, Lfdobj=NULL, lambda=lambda_f)
D_splinebasis_trc <- create.bspline.basis(range(r_trunc_values), splines_D, norder=4)
betafdPar_D = fdPar(D_splinebasis_trc, Lfdobj=NULL, lambda=lambda_D)
if (Dconst) {
gamma_fRegress <- fRegress(gamma_fd$fd,
xfdlist=list(f_term_fd, D_term_fd),
betalist=list(betafdPar_f,
fdPar(constbasis_trc)))
} else {
gamma_fRegress <- fRegress(gamma_fd$fd,
xfdlist=list(f_term_fd, D_term_fd),
betalist=list(betafdPar_f,
betafdPar_D))
}
gamma_betaestlist <- gamma_fRegress$betaestlist
gamma_yhat_mat <- eval.fd(r_trunc_values, gamma_fRegress$yhatfdobj$fd)
gamma_rmatb   <- gamma - gamma_yhat_mat
gamma_sigma_eb <- var(t(gamma_rmatb))
gamma_y2cMap <- gamma_fd$y2cMap
# Produce standard error to produce 95% confidence intervals:
gamma_betastderrlist <- fRegress.stderr(gamma_fRegress, gamma_y2cMap, gamma_sigma_eb)
gamma_betaestlist <- gamma_fRegress$betaestlist
# Save plots to working directory
if(SAVE==TRUE){
fds_gamma_fd <- fds(x=r_trunc_values, y=eval.fd(r_trunc_values, gamma_fd$fd))
pdf(paste(working_dir, '/gamma.pdf', sep=''))
plot(fds_gamma_fd, xlab="r", ylab="gamma", xlim=range(r_trunc_values))
dev.off()
f <- eval.fd(r_trunc_values, gamma_betaestlist[[1]]$fd)
upper_err <- eval.fd(r_trunc_values, gamma_betaestlist[[1]]$fd + 2*gamma_betastderrlist$betastderrlist[[1]])
lower_err <- eval.fd(r_trunc_values, gamma_betaestlist[[1]]$fd - 2*gamma_betastderrlist$betastderrlist[[1]])
f_df <- data.frame(r=r_trunc_values, f, lower_err, upper_err)
write.csv(f_df, file=paste(working_dir, "/f.csv", sep=''), row.names=FALSE, quote=FALSE)
pdf(paste(working_dir, '/f.pdf', sep=''))
plot(r_trunc_values, f, type="l", lwd=3,
xlim=range(r_trunc_values),
ylim=c(min(lower_err), max(upper_err, 0)),
xlab="r", ylab="f")
lines(r_trunc_values, lower_err, lwd=2, lty=3)
lines(r_trunc_values, upper_err, lwd=2, lty=3)
abline(h=0, lwd=2, lty=1, col="blue")
dev.off()
D <- eval.fd(r_trunc_values, -gamma_betaestlist[[2]]$fd)
upper_err <- eval.fd(r_trunc_values, -gamma_betaestlist[[2]]$fd + 2*gamma_betastderrlist$betastderrlist[[2]])
lower_err <- eval.fd(r_trunc_values, -gamma_betaestlist[[2]]$fd - 2*gamma_betastderrlist$betastderrlist[[2]])
D_df <- data.frame(r=r_trunc_values, D, lower_err, upper_err)
write.csv(D_df, file=paste(working_dir, "/D.csv", sep=''), row.names=FALSE, quote=FALSE)
pdf(paste(working_dir, '/D.pdf', sep=''))
plot(r_trunc_values, D, type="l", lwd=3,
xlim=range(r_full),
ylim=c(min(lower_err, 0), max(upper_err)),
xlab="r", ylab="D")
lines(r_trunc_values, lower_err, lwd=2, lty=3)
lines(r_trunc_values, upper_err, lwd=2, lty=3)
abline(h=0,lwd=2,lty=1,col="blue")
dev.off()
}
}
lambda_R_dt_disc = (n_agents_R[-1]-n_agents_R[-length(n_agents_R)])/tau
plot((n_agents_R[-1]-n_agents_R[-length(n_agents_R)]))
Kd_fd = deriv(Ksmooth$fd)
splines_g=30
g_splinebasis_trc <- create.bspline.basis(range(r_full), splines_g, norder=4) #20
constbasis <- create.constant.basis(range(r_full))
const_term = rep(1,n_time_steps-1)
loglam = seq(0,18,0.5)
nlam   = length(loglam)
GCV1 = matrix(0,nlam,1)
OCV1 = matrix(0,nlam,1)
p_min1 = matrix(0,nlam,1)
GCV2 = matrix(0,nlam,1)
OCV2 = matrix(0,nlam,1)
p_min2 = matrix(0,nlam,1)
for (ilam in 1:nlam){
print(ilam)
lambda = 10^loglam[ilam]
lambda_g = lambda # Soothing parameter used in fitting g funcitonal data estimates.
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
fRegi = fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
GCV1[ilam] = fRegi$gcv
OCV1[ilam] = fRegi$OCV
g_yhat_mat <- fRegi$yhatfdobj
SSE0 = sum((lambda_R_dt_disc)^2)
SSE1 = sum((lambda_R_dt_disc - g_yhat_mat)^2)
RSQ = (SSE0-SSE1)/SSE0
Fratio1 = ((SSE0-SSE1)/(fRegi$df-1))/(SSE1/(length(lambda_R_dt_disc)-fRegi$df))
p_min1[ilam] = pf(Fratio1,(fRegi$df-1),(length(lambda_R_dt_disc)-fRegi$df),lower.tail = F)
fRegi = fRegress(y=lambda_R_dt_disc,
xfdlist=list(const_term,
Kd_fd[-n_time_steps]),
betalist=list(constbasis,
betafdParg))
GCV2[ilam] = fRegi$gcv
OCV2[ilam] = fRegi$OCV
g_yhat_mat <- fRegi$yhatfdobj
SSE0 = sum((lambda_R_dt_disc - mean(lambda_R_dt_disc))^2)
SSE1 = sum((lambda_R_dt_disc - g_yhat_mat)^2)
RSQ = (SSE0-SSE1)/SSE0
Fratio1 = ((SSE0-SSE1)/(fRegi$df-1))/(SSE1/(length(lambda_R_dt_disc)-fRegi$df))
p_min2[ilam] = pf(Fratio1,(fRegi$df-1),(length(lambda_R_dt_disc)-fRegi$df),lower.tail = F)
}
plot(loglam,GCV1)
plot(loglam,OCV1)
plot(loglam,p_min1)
print(loglam[which(GCV1==min(GCV1))])
print(loglam[which(OCV1==min(OCV1))])
print(loglam[which(p_min1==min(p_min1))])
lambda_g = 10^13
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_ndash = 10^6 # Smoothing parameter used to smooth the number of agents in R. Used to analyse birth death processes.
splines_ndash = 100
n_splinebasis <- create.bspline.basis(range((times_unique)), splines_ndash)
ndt_fdPar <- fdPar(fdobj=n_splinebasis, Lfdobj=NULL, lambda=lambda_ndash)
ndtsmooth <- smooth.basis(argvals=times_unique[-n_time_steps],
y=lambda_R_dt_disc,
fdParobj=ndt_fdPar)
lambda_R_dt_smth = eval.fd(times_unique[-n_time_steps],ndtsmooth$fd)
plot(times_unique[-1],lambda_R_dt_disc)
lines(ndtsmooth)
plot(ndtsmooth)
lambda_R_dt_disc = lambda_R_dt_smth[,1]
lambda_g = 10^13
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
loglam = seq(0,18,0.5)
nlam   = length(loglam)
GCV1 = matrix(0,nlam,1)
OCV1 = matrix(0,nlam,1)
p_min1 = matrix(0,nlam,1)
GCV2 = matrix(0,nlam,1)
OCV2 = matrix(0,nlam,1)
p_min2 = matrix(0,nlam,1)
for (ilam in 1:nlam){
print(ilam)
lambda = 10^loglam[ilam]
lambda_g = lambda # Soothing parameter used in fitting g funcitonal data estimates.
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
fRegi = fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
GCV1[ilam] = fRegi$gcv
OCV1[ilam] = fRegi$OCV
g_yhat_mat <- fRegi$yhatfdobj
SSE0 = sum((lambda_R_dt_disc)^2)
SSE1 = sum((lambda_R_dt_disc - g_yhat_mat)^2)
RSQ = (SSE0-SSE1)/SSE0
Fratio1 = ((SSE0-SSE1)/(fRegi$df-1))/(SSE1/(length(lambda_R_dt_disc)-fRegi$df))
p_min1[ilam] = pf(Fratio1,(fRegi$df-1),(length(lambda_R_dt_disc)-fRegi$df),lower.tail = F)
fRegi = fRegress(y=lambda_R_dt_disc,
xfdlist=list(const_term,
Kd_fd[-n_time_steps]),
betalist=list(constbasis,
betafdParg))
GCV2[ilam] = fRegi$gcv
OCV2[ilam] = fRegi$OCV
g_yhat_mat <- fRegi$yhatfdobj
SSE0 = sum((lambda_R_dt_disc - mean(lambda_R_dt_disc))^2)
SSE1 = sum((lambda_R_dt_disc - g_yhat_mat)^2)
RSQ = (SSE0-SSE1)/SSE0
Fratio1 = ((SSE0-SSE1)/(fRegi$df-1))/(SSE1/(length(lambda_R_dt_disc)-fRegi$df))
p_min2[ilam] = pf(Fratio1,(fRegi$df-1),(length(lambda_R_dt_disc)-fRegi$df),lower.tail = F)
}
plot(loglam,GCV1)
plot(loglam,OCV1)
plot(loglam,p_min1)
print(loglam[which(GCV1==min(GCV1))])
print(loglam[which(OCV1==min(OCV1))])
print(loglam[which(p_min1==min(p_min1))])
lambda_g = 10^10.5
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_g = 10^15
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_R_dt_disc = (n_agents_R[-1]-n_agents_R[-length(n_agents_R)])/tau
lambda_ndash = 10^6 # Smoothing parameter used to smooth the number of agents in R. Used to analyse birth death processes.
splines_ndash = 100
n_splinebasis <- create.bspline.basis(range((times_unique)), splines_ndash)
ndt_fdPar <- fdPar(fdobj=n_splinebasis, Lfdobj=NULL, lambda=lambda_ndash)
ndtsmooth <- smooth.basis(argvals=times_unique[-n_time_steps],
y=lambda_R_dt_disc,
fdParobj=ndt_fdPar)
lambda_R_dt_smth = eval.fd(times_unique[-n_time_steps],ndtsmooth$fd)
plot(times_unique[-1],lambda_R_dt_disc)
lines(ndtsmooth)
plot(ndtsmooth)
lambda_R_dt_disc = lambda_R_dt_smth[,1]
lambda_g = 10^15
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_R_dt_disc = (n_agents_R[-1]-n_agents_R[-length(n_agents_R)])/tau
lambda_g = 10^15
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_g = 10^15
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
g_yhat_mat <- g_fRegress_gr$yhatfdobj
g_rmatb   <- lambda_R_dt_disc - g_yhat_mat
g_y2cMap <- Kd_fd$y2cMap
SigmaE.= sum(g_rmatb^2)/(length(g_yhat_mat)-g_fRegress_gr$df)
SigmaE = SigmaE.*diag(rep(1,length(g_yhat_mat )))
stderrList = fRegress.stderr(g_fRegress_gr,
g_y2cMap,
SigmaE)
g2_t_tvar <- eval.fd(r_full, g_fRegress_gr$betaestlist[[1]]$fd)
g1_tvar_sde <- eval.fd(r_full, stderrList$betastderrlist[[1]])
fds_g_mat_upper = fds(x=r_full, y=g2_t_tvar+2*g1_tvar_sde)
fds_g_mat_lower = fds(x=r_full, y=g2_t_tvar-2*g1_tvar_sde)
plot(g_fRegress_gr$betaestlist[[1]],ylim=c(min(g2_t_tvar-2*g1_tvar_sde),max(g2_t_tvar+2*g1_tvar_sde)))
lines(fds_g_mat_upper,lty=2)
lines(fds_g_mat_lower,lty=2)
plot(loglam,GCV1)
plot(loglam,OCV1)
plot(loglam,p_min1)
lambda_R_dt_disc = (n_agents_R[-1]-n_agents_R[-length(n_agents_R)])/tau
plot((n_agents_R[-1]-n_agents_R[-length(n_agents_R)]))
Kd_fd = deriv(Ksmooth$fd)
splines_g=30
g_splinebasis_trc <- create.bspline.basis(range(r_full), splines_g, norder=4) #20
constbasis <- create.constant.basis(range(r_full))
const_term = rep(1,n_time_steps-1)
loglam = seq(0,18,0.5)
nlam   = length(loglam)
GCV1 = matrix(0,nlam,1)
OCV1 = matrix(0,nlam,1)
p_min1 = matrix(0,nlam,1)
GCV2 = matrix(0,nlam,1)
OCV2 = matrix(0,nlam,1)
p_min2 = matrix(0,nlam,1)
for (ilam in 1:nlam){
print(ilam)
lambda = 10^loglam[ilam]
lambda_g = lambda # Soothing parameter used in fitting g funcitonal data estimates.
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
fRegi = fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
GCV1[ilam] = fRegi$gcv
OCV1[ilam] = fRegi$OCV
g_yhat_mat <- fRegi$yhatfdobj
SSE0 = sum((lambda_R_dt_disc)^2)
SSE1 = sum((lambda_R_dt_disc - g_yhat_mat)^2)
RSQ = (SSE0-SSE1)/SSE0
Fratio1 = ((SSE0-SSE1)/(fRegi$df-1))/(SSE1/(length(lambda_R_dt_disc)-fRegi$df))
p_min1[ilam] = pf(Fratio1,(fRegi$df-1),(length(lambda_R_dt_disc)-fRegi$df),lower.tail = F)
fRegi = fRegress(y=lambda_R_dt_disc,
xfdlist=list(const_term,
Kd_fd[-n_time_steps]),
betalist=list(constbasis,
betafdParg))
GCV2[ilam] = fRegi$gcv
OCV2[ilam] = fRegi$OCV
g_yhat_mat <- fRegi$yhatfdobj
SSE0 = sum((lambda_R_dt_disc - mean(lambda_R_dt_disc))^2)
SSE1 = sum((lambda_R_dt_disc - g_yhat_mat)^2)
RSQ = (SSE0-SSE1)/SSE0
Fratio1 = ((SSE0-SSE1)/(fRegi$df-1))/(SSE1/(length(lambda_R_dt_disc)-fRegi$df))
p_min2[ilam] = pf(Fratio1,(fRegi$df-1),(length(lambda_R_dt_disc)-fRegi$df),lower.tail = F)
}
plot(loglam,GCV1)
plot(loglam,OCV1)
plot(loglam,p_min1)
print(loglam[which(GCV1==min(GCV1))])
print(loglam[which(OCV1==min(OCV1))])
print(loglam[which(p_min1==min(p_min1))])
print(loglam[which(GCV2==min(GCV2))])
lambda_g = 10^12.5
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_g = 10^13
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
lambda_g = 10^14
betafdParg = fdPar(g_splinebasis_trc, Lfdobj=NULL, lambda=lambda_g)
g_fRegress_gr <- fRegress(y=lambda_R_dt_disc,
xfdlist=list(Kd_fd[-n_time_steps]),
betalist=list(betafdParg))
plot(g_fRegress_gr$betaestlist[[1]])
max(dtb_mat$distance_bolus)
min(dtb_mat$distance_bolus)
hist(dtb_mat$distance_bolus)
setwd("~/Dropbox/WholeWellAnalysis/Simulations/Cog-preembed31817")
working_dir <- '~/Dropbox/WholeWellAnalysis/Simulations/Cog-preembed31817' # '../imaris/WholeWellData'
dir <- "Cog-preembed31817"
SAVE = T
# Distance to bolus for each cellular position recorded
dtb_mat_out <- read.csv(paste(working_dir, "/2017-08-31 OT-I_CMTMR_EL4_SIIN_Red_OT-I_GFP_16h_stitched_bolus_spots_Intensity_Center_Ch=4_Img=1.csv", sep=''),
skip=3,
# null indicates ignored columns. Note last column, all lines in file end with ','.
colClasses=c(NA,"NULL","NULL","NULL","NULL", NA, NA,"NULL"))
colnames(dtb_mat_out)[1] = "distance_bolus"
dim(dtb_mat_out)
max(dtb_mat_out$distance_bolus)
max(dtb_mat$distance_bolus)
dtb_mat_in <- read.csv(paste(working_dir, "/2017-08-31 OT-I_CMTMR_EL4_SIIN_Red_OT-I_GFP_16h_stitched_bolus_spots_Intensity_Center_Ch=5_Img=1.csv", sep=''),
skip=3,
# null indicates ignored columns. Note last column, all lines in file end with ','.
colClasses=c(NA,"NULL","NULL","NULL","NULL", NA, NA,"NULL"))
colnames(dtb_mat_in)[1] = "distance_bolus"
min(dtb_mat_in$distance_bolus)
max(dtb_mat_in$distance_bolus)
min(dtb_mat_out)
-dtb_mat_in[which(dtb_mat_out$distance_bolus==0),1]
dtb_mat = dtb_mat_out
dtb_mat[which(dtb_mat_out$distance_bolus==0),1] = -dtb_mat_in[which(dtb_mat_out$distance_bolus==0),1]
maxdtb_mat()
max(dtb_mat)
max(dtb_mat$distance_bolus)
hist(dtb_mat$distance_bolus)
if(brth_dth ==T){
dtb_file <- paste(working_dir, "/distances_to_bolus_R.csv", sep='')
}else{
dtb_file <- paste(working_dir, "/distances_to_bolus.csv", sep='')
}
if (!file.exists(dtb_file)) {
print(dtb_file)
stop('specified distance to bolus file does not exist')
}
# Distance to bolus. Table must contain two columns, distance and then times at which those distances were observed
# TODO rename this, it's not a matrix for a start. It's a list.
dtb_mat <- read.csv(dtb_file,
skip=0,
colClasses=c(NA,NA))
dtb_mat <- dtb_mat[order(dtb_mat$Time), ]  # Sort by monotonically increasing time.
dtb_mat$Time <- dtb_mat$Time
max(dtb_mat$distance_bolus)
times_unique <- unique(dtb_mat$Time)
if (TMAX == -1)
{ TMAX <- length(times_unique)}
if (TMIN == -1)
{ TMIN <- 1}
dtb_mat <- dtb_mat[which((dtb_mat$Time>=times_unique[TMIN])&(dtb_mat$Time<=times_unique[TMAX])),]
times_unique <- unique(dtb_mat$Time)
max(dtb_mat$distance_bolus)
hist(dtb_mat$distance_bolus)
